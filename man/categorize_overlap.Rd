% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/overlaps.R
\name{categorize_overlap}
\alias{categorize_overlap}
\title{Categorizing overlapping entities}
\usage{
categorize_overlap(
  x,
  start_col,
  end_col,
  experimental = FALSE,
  corpus = NULL,
  verbose = TRUE
)
}
\arguments{
\item{x}{The input \code{data.table} containing an overlap ID for each group of
overlapping entities.}

\item{start_col}{A \verb{character vector} of length 1, referring to the name of
the column containing the start positions of the regions to be compared.}

\item{end_col}{A \verb{character vector} of length 1, referring to the name of the
column containing the end positions of the regions to be compared.}

\item{experimental}{A \verb{logical value} of whether to add "outer" or "inner"
annotations to partially overlapping entities. See discussion in "details".}

\item{corpus}{A \verb{character vector} with the name of the CWB corpus the
documents are retrieved from. Used to create a token stream when argument
\code{experimental} is set to TRUE. Defaults to NULL.}

\item{verbose}{A \verb{logical value} of whether to print messages or not.}
}
\value{
A \code{data.table} with the input \code{data.table} plus multiple column
containing \code{boolean} values. The function \code{resolve_overlap()} can be used
thereafter to select the most appropriate entity in the overlap.
}
\description{
The function categorizes overlapping regions of annotations in a \code{data.table}
object and assigns types to each overlapping entity.
\strong{This functionality is currently experimental}. The correctness of results
is subject of ongoing checks. The syntax is likely to change in future
updates.
}
\details{
\code{categorize_overlap()} returns the input data.table with additional
columns containing \code{boolean} values for specific overlap types. These types
are informed by discussions about nested entities in the field of Named
Entity Recognition, see for example Benikova et al. (2014). One entity can
contain multiple overlap types. These columns currently are:
\itemize{
\item \code{ovl_longest}: If entities completely overlap, i.e. all entities are
part of another entity, \code{ovl_longest} = TRUE describes the longest entity
in the overlap. Example: "Vice President Gore" is annotated both fully
("Vice President Gore") and as only a part of the span (e.g. "Gore"). If
both entities refer to the same URI, then "Vice President Gore" is assigned
as the "longest" match while "Gore" is assigned as the "shortest" match in
the overlap.
\item \code{ovl_shortest}: If entities completely overlap, i.e all entities are part
of another entity, \code{ovl_shortest} = TRUE indicates the shortest entity in
the overlap. See "Gore" in the example above.
\item \code{ovl_partial}: If entities overlap only partially, this is indicated by
\code{ovl_partial} = TRUE. Example: The span "Crude oil prices" is annotated as
both "Crude oil" and "oil prices" with distinct URIs.
\item \code{ovl_inner}: If entities overlap only partially (see above), the
character span included in all entities (i.e. their intersecting
characters) are indicated by \code{ovl_inner} = TRUE. Example: "Crude oil
prices" is annotated by both "Crude oil" and "oil prices". The inner
overlap of these entities is "oil". Only created when argument
\code{experimental} = TRUE.
\item \code{ovl_outer}: If entities overlap only partially (see above), the span
describing the maximal extension of all entities is indicated by
\code{ovl_outer} = TRUE. Example: "Crude oil prices" is annotated by both "Crude
oil" and "oil prices". The outer overlap of these entities is "Crude oil
prices". Only created when argument \code{experimental} = TRUE.
\item \code{ovl_multiple}: If multiple entities describe the same span, this is
indicated by \code{ovl_multiple} = TRUE. This can happen when the tokenization
of DBpedia Spotlight is different from the tokenization of the input data
resulting in sub-token annotations. This also potentially occurs with
\code{ovl_inner} and \code{ovl_outer} when different entities are concatenated.
Example: "Crude oil prices" is concatenated by the annotation of "Crude
oil" and "oil prices", both described by different URIs. The combined
entity contains then two distinct URIs, which is indicated by
\code{ovl_multiple} = TRUE in addition to \code{ovl_outer} = TRUE.
\item \code{ovl_distinct}: If entities overlap only partially (see above) and both
entities describe distinct concepts, then this is indicated by
\code{ovl_distinct} = TRUE. Example: The span "Crude oil prices" is annotated as
both "Crude oil" and "oil prices" with distinct URIs and thus is both
\code{ovl_partial} = TRUE and \code{ovl_distinct} = TRUE.
\item \code{ovl_undetermined}: Overlaps which do not fall under the categories above
are indicated by \code{ovl_undetermined} = TRUE.
}

The main purpose of the - currently experimental - types of \code{ovl_outer} and
\code{ovl_inner} is to identify instances in which multiple overlapping entities
describe the same concept.
}
\examples{
doc <- "Crude oil prices on the rise."

x <- get_dbpedia_uris(
  x = doc,
  max_len = 5600L,
  confidence = 0.35,
  api = "https://api.dbpedia-spotlight.org/en/annotate",
  language = "en",
  types = character(),
  support = 20,
  types_src = c("DBpedia", "Wikidata"),
  verbose = TRUE
) |>
  detect_overlap(start_col = "start", verbose = TRUE) |>
  categorize_overlap(start_col = "start",
                     end_col = "end",
                     experimental = TRUE,
                     verbose = TRUE)
}
\references{
Darina Benikova, Chris Biemann, and Marc Reznicek. 2014. NoSta-D
Named Entity Annotation for German: Guidelines and Dataset. In Proceedings
of the Ninth International Conference on Language Resources and Evaluation
(LREC'14), pages 2524â€“2531, Reykjavik, Iceland. European Language Resources
Association (ELRA).
}
