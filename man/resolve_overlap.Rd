% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/overlaps.R
\name{resolve_overlap}
\alias{resolve_overlap}
\title{Resolve overlapping entities}
\usage{
resolve_overlap(x, keep, omit = NULL, tiebreak, verbose = TRUE)
}
\arguments{
\item{x}{The input \code{data.table} containing annotations with classified
overlaps.}

\item{keep}{A \verb{character vector} of the names of the overlap types to be
kept. These should refer to the types described in \code{?categorize_overlap}
without the leading \code{ovl_}, i.e. to \code{longest}, \code{shortest}, etc. If the
length of the \verb{character vector} is longer than 1, columns are evaluated in
order, i.e the first column is preferred over the second, etc.}

\item{omit}{A \verb{character vector} of the names of the overlap types to be
omitted from the final output. These should refer to the types described in
\code{?categorize_overlap} without the leading \code{ovl_}, i.e. to \code{longest},
\code{shortest}, etc.}

\item{tiebreak}{A \verb{character vector} describing a strategy to handle
unresolved overlaps, i.e. groups of overlapping entities in which the
combination of \code{keep} and \code{omit} does not indicate a single remaining
entity. Valid values are \code{first} (for each unresolved overlap, keep the
first entity in the order of the row index), \code{sample} (for each unresolved
overlap, sample one random entity) or \code{remove} (for each unresolved
overlap, remove all entities).}

\item{verbose}{A \verb{logical value} of whether to print messages or not.}
}
\value{
A \code{data.table} only containing one entity per overlap.
}
\description{
The function resolves detected and categorized overlapping regions of
annotations in a \code{data.table} object.
\strong{This functionality is currently experimental}. The correctness of results
is subject of ongoing checks. The syntax is likely to change in future
updates.
}
